Javascript's greatest departure from Java is the way that it handles inheritance. As stated before, the concept of Classes, Interfaces, and Abstracts does not exist within the syntax. To people who have learned Object Orientend Programming revolving around these concepts, the lack of these concepts is confusing. To fully understand how important this is, let's recap the basics of class-based inheritance quickly:

Let us say you have a series of classes that execute similar tasks, have similar or even identical fields and methods. However these classes are distinct from each other enough to be considered separate. In order to to prevent having to rewrite similar methods and declare similar fields over and over again, making for some incredibly messy code, a parental class is created in an IS-A relationship scheme. This parental class abstracts the common and repeated code among all the classes, making our previous collection of messy classes free of it. In turn. the now child classes extend the parental class in a one-to-one relation. A class cannot have multiple parents, but a class can have any amount of child classes that extend it. The child classes then serve as a blueprint to instantiate objects that also hold this relation. Parental classes that merely abstract code and don't have a use of being objects are called abstract and interfaces skirt around the problem single-parent inheritance by defining empty method headers. This is the way Java, C#, and other languages solve the inheritance problem.

(example 14)
Javascript does things radically different: It implements prototype-based programming, also called prototypal, classless or instance-based programming. As stated before, in JS there are no explicit parental or child-classes or objects. Instead, they are linked through a property: The prototype, a data construction that contains initial members and their starting values. Prototypes are accesible through the __proto__ variable, and all prototype variables are accesible to the object as if it were their own. There are two ways of creating objects: From nothing, using literals, and cloning the prototype of an existing object. However, the first way is a misnomer, as all empty objects are clones of the Root Object. The Root Object is the default prototype for all newly created empty objects. Using the object literal means cloning the Root Object prototype and placing it as the prototype of the object. As such, we are already inherting fields, their values, and methods from an object, right from the get-go. The Root Object is a prototype for the rest of the objects. In order to inherit the properties of a previously declared and initialized object, the syntax to use is var child = Object.create(parent). What this does is that it copies the parent object and assigns it to the prototype of the child. In this manner, the child object has a direct, one to one relation with the parent akin to classical inheritance. This is the same as declaring child.__proto__ = parent, however the previous syntax results into a much cleaner solution that does two things at once: It creates an empty object and injects it with a reference to a prototype, which is the parent. This makes two questions arise: One, what happens when we have two variables on the same object, one declared inside the object, the other inside it's prototype? What gets called? And two, what happens if we change the value within a prototype? The answer to question number one is simple: When an object has the same name for two variables inside the object body and the protoype, the most local scope takes precedence. The prototype value does not dissappear, however it simply does not return if the object's fields are queried. The answer to number two is a bit trickier: If object B has by prototype object A, making A parent of B, should any change happen to the prototype of B will be reflect on A itself. Also, if after establishing the prototype relationship A is modified, those changes will be reflected on B.

This means its possible for a child to change the state of a parent. Up to now I have been using the terms child and parent, but only doing so as a crutch to transition the thought process from Java to Javascript. The greatest strength of prototypal inheritance is that it eschews the concept of a top-down tree of inheriting data over multiple classes, or objects. Even after lending their data after establishing inheritance, the objects remain free to be modified and accesed, and their "children" will have those changes reflected on them.

However, as with everything there are multiple ways of tackling the same problem and Javascript is no exception. Extending objects through the use of Object.create() is not the only way to create inheritance. Due to the fact that functions are also objects, they can also be extended. These are constructor functions, a holdover from classical inheritance. It's important to note that there is no syntactic difference between regular functions and constructor functions. Constructor functions can be called and assigned as fields just like regular function. However, they become constructor when they are used like so:
/*
	var Vehicle = function Vehicle() {
  		// ...
	}
	var mazda = new Vehicle();
*/

The use of the new keyword may confuse you, as this is usually associated with classes and objects. The instantiation of a variable with a "new" keyword does the following: It creates a new empty object, like instantiating with the object literal. It sets the sets the object to delegate all shared data and methods to the prototype of the Vehicle() function, which means that the new object shares data with the function object, and sets the constructor property of the object to Vehicle. This is a new property that we had not discussed: In addition to being able to share data with an object through prototype, objects have a constructor property that contains a function that is executed when the object is generated by the Virtual Machine. In our previous example, whatever is contained within the Vehicle constructor is executed as many times as we create objects using /* new Vehicle() */, within the local context of the object. The constructor exists within the prototype, as object.prototype.constructor.  With this, the new objects inherit all properties and functions detailed within the constructor execution. It's important to note that creating objects through Object.create() means leaving an empty constructor. This approach is the most popular since, for a time, it was the only apporoach for inheritance in Javascript. However, in recent years this method has been decried as a messy way to create objects that inherit data and methods from others. That being said, this is an approach that can be seen in many frameworks and external libraries, and a JS programmer would do well to learn it. For further information, please check out David Walsh's Javascript Objects Deconstruction. 

In both the Object.create() method and the constructor/new method of inheritance, we are chaining the prototype of our parental object to that of the new objects we create with data on them. This is to delegate execution of code not found within the local scope objects and instead doing it in the objects that are already within memory. This practice removes the need for redundant code and encapsulates local variables and methods where they should be. 

Another strength of JavaScript's approach to object-orientation is Object Augumentation. If we want an object that is slightly different than another, instead of writing an entire new class in Java, we can simply override or add new methods and variables to an object once it has a prototype. We can then have other objects derive from it, and so on. We can even override the native Object methods, such as .toString(), as if we were just putting something new into an object: (example 15).

If we create an object using myParenizor as a prototype, then that object has the overriden toString() method.

Another approach to inheritance, one that eschews the IS-A relationship entirely, is called Parasitic Inheritance, where a function takes another function, or functions, and incorporates its own methods and values into it and returns the modified function as if it was its own output. This pattern is also demonstrated by Douglas Crockford. (example 16)

Again, taking advantage of functions being objects in javascript, this approach makes it possible to cherry-pick methods and fields from various objects, put them all into one and return it, the "parasites" already ready to be used. In the words of Crockford: Parasitic inheritance is about the was-a-but-now's-a relationship. The constructor has a larger role in the construction of the object.

However, this is not the end of inheritance in Javascript. In the coming years, the 6th edition of the ECMAScript standard will be implemented in browsers, devices and everywhere where Javascript is being executed. The standard, codenamed Harmony, is being partially implemented in many compilers, engines and browsers today. This year, 2014, its feature list was frozen, and it will see a full release by mid-2015. Among these features is the "Class", a data structure that is meant to emulate the classical inheritance model of Java. Under the ES6 standard, Classes will have a place in the Javascript syntax, alongside the prototypal inheritance the language was built upon. It will look like this: (example 17)

It's important to ntoe that the Class structure is merely syntatic sugar the previously discussed Objects and prototypes, offering a cleaner way to create objects and deal with inheritance. You can create new objects from classes and extend them in the traditional one-to-one relation. No implementation of abstracts or interfaces is planned. It was created in order to port libraries and software in a much easier way, and to faciliate adoption of a much larger developer community. For now, there is no browser that implements this structure, and the standard hasn't fully been formed yet, but it's only a matter of time until it comes to browsers and devices.

If you cannot wait for 2015, Typescript is a strong alternative. Created by Andres Hejlsberg, curated and maintained by Microsoft, Typescript is a free and open source programming language that mimics Javascript syntax. However, it incorporates many features that bring it closer to the C-family languages: It supports the use of classes and interfaces, header files, variable type checking, and supports generics programming. Any valid Javascript code is valid Typescript code, and it fully supports ECMAScript version 3, with support for versions 5 and 6 coming soon. Its compiler transcodes Typescript into Javascript, making it executable on any engine. It's fully integrated with Visual Studio 2013, and is supported by JetBrains Webstorm. The compiler is also available as a module in npm.

For further information about Javascript Inheritance please check out Source Decoded - Prototypes, Prototypical Inheritance done right.