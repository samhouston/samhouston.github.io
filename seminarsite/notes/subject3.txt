It's important to note from the get-go that, despite being named after it, Javascript is not a subset of Java in any way, shape or form. The syntax and designed were inspired by Java, however that is where the similarities end. Due to the fact that the intended audience is familiar with the Java Programming Language, I will stop every so often to indicate where Javascript departs from Java in significant and profound ways. That being said, the best analogy I have found on the web is "Javascript is to Java what car is to carpet." They share letters, and some key elements. However, they are not related.

(view example 3)
The Javascript syntax looks like a hybrid between the reserved keywords of Java and the clarity and effctiveness of Python, and with good reason: Its HyperTalk roots caused the syntax to be simple as it is. Javascript shares the same Unary, binary, arithmetic, comparison, logical and assignment operators as Java. Furthermore, identifiers in Javascript are case sensitive for all data types, declaring variables and assinging them values just like any C-based language. The "+" sign is overloaded for both addition and string concatenation. Un-intialized identifiers hold an undefined value. Single-lined and Multi-lined comments work exactly like Java. 

Statements are terminated with a semicolon as a best practice. I say "best practice" because the JavaScript Virtual Machine does not actually require them. Spaces, tabs, and new lines, in a parallel to Python, play a significant role in syntax. If a semicolon is missing, the Virtual Machine places the punctuation by itself where a statement is parsable and well formed. However, this may lead to unintended effects in runtime, causing two statements to run like one and other oddities. Because of this, it is recommended that every statement should be terminated with a semi-colon, and instead use whitespace and tabs as a way to space out the code and make human-readable. 

The keen eye may have noticed an immediate departure from the usual fare of programming languages, if all you have ever done is ever Java or C: Variables are not declared by their type. This is because Javascript implements duck typing: Any identifier can store any sort of variable. This can be hard to process and it requires a shift in thinking about computation. After all, how do you make sure a variable is of a certain type before trying to start an illegal operation, such as invoking a String method on a number? For such needs, Javascript incorporates a typeof operand that outputs the type of a variable compared to another variable or its class name (example 4). 

How is it possible to have a single variable intializer without indicating its type? It would sound absolutely insane to a person used to think in C and Java. The answer is incredibly simple: There is no such thing as a primitive type in Javascript. 

In Javascript, in one way or another everything is an object. 

There is no such thing as a primitive data type in Javascript, or at least in the way we think about them. In fact there is no concept of integers, floats, or shorts. The distinction between Methods and Objects does not exist. The only thing that approaches what we think of as primitive data are numbers and boolean, and even numbers are debatably objects that box and un-box automatically much like the Primitive Wrapper Classes in Java. At any rate, Javascript eschews the concept of distingushing between two types of data and chooses to declare, initialize, and use them on the same manner.

In Javascript, variables are function-scoped, rather than being block-scoped like tradtional C-based languages. This means that, technically, you could make use of the iterator variable of a for loop outside of said for loop. What's more, if a variable is declared outside of a function scope, or without the "var" keyword, they are incoroprated into the Global Object (more on that later), and placed on what could be called an equivalent to a public access modifier. These variables are not subject to order of initialization: You could add a number to a variable that comes after it. This is called variable hoisting. When referencing an identifier, the Virtual Machine goes through what you could call a reverse-matryoshka: It checks the most immediate local variable scope and progressively traverses broader and broader scopes until it checks the global object scope, where everything else is contained. If the Virtual Machine cannot find the identifier after traversing from the local to the global scope, the scope chain, then it's time to output an error. This is a huge departure from Java and others, where the scope of variables and references is tightly controled through access modifiers, class fields, and static identifiers (example 5). 

In Javascript there is but one number type and that is Number, a 64-bit floating point, usually thought of as Double in other statically typed languages. In previous iterations, Javascript had  glitches in arithmetic computing, however this has been fixed in the Version 5 of the ECMA Script Standard. 

When an invalid number operation takes place, such as a division of a number by a string, the value takes the form of NaN, a special number reserved for either undefined or erroneous operations. It propagates quickly, as any operation with NaN as a factor will have NaN as result. Oddly enough, one cannot check against this fallback value, as console.log(NaN === NaN) is false. This is not really helpful, as it doesn't indicate where exactly the computation would go wrong, as opposed to Java, which would return a runtime error. Remember, Javascript was designed to run in the background, as such it's very silent about it's errors unless the developer really knows what he or she is doing. To parse a String into a Number, the Global Object provides a method called parseInt(). The Number() method also servers this function (example 6).

Javascript provides a Boolean data type, expressed as true and false literals. Logical and comparison operators work identically in Java. The place of major departure consists in the interpretation of values belonging to other data types. Douglas Crockford describes them as "truthy" and "falsy" when some values are evaluated in the comparison and logical context. For example, if we type console.log(true == 0), we will recieve a false statement. Javascript will interpret as "false" the following: The number 0, empty strings, strings containing the number 0, and the null operator. NaN and undefined, the initalizing value of all variables, are interpreted as neither true nor false. This is a quirk of the language that has creates a type checking problem for some algorithms and implementations. (example 7)

Strings are handled similarly to the Java implementation of these objects: They are sequences of UTF-16 code units, immutable, with string literals able to use single and double quotes for their declaration. Unlike Java, string comparison is done using the == operator. You can know the length of a string using the .length field. Parsing a Number or Array into a String is done using the String() method. Like Java, the String object in JavaScript has a number of methods that create a new, modified string. These methods include charAt, indexOf, match (for checking against a regular expression), slice, substring, toLowerCase and toUpperCase. If you are familiar with the String class in basically any C-based language, you should be able to know what these are. You can concatenate strings using the + operand or a concat() method if you want to.(example 8)

Arrays in Javascript behave very differently from their Java counterparts. In fact they have more in common with the List Abstract Structure. For one, they are dynamic in size, with the user being able to push objects into an empty array. Due to the typing nature of variables in JS, arrays are able to hold multiple data types in one single structure. Like Java, their indexing scheme is zero based and return their size with the .length field. Array literals are declared using square brackets, with their elements separated by commas. They can also be declared through the constructor-esque method new Array(), with a predefined size. Furthermore, arrays have built in methods that modify its data: join(), to put all array elements into a string,  slice(), in order to create a subset of an array, push() to place an element at the end of an array. (example 9)

Control Structures, such as if/else, try/catch, switch, do/while, while, and for loops are all identical to their Java counterparts. Bear in mind that due to the fact that variables are not scope-blocked, but function-blocked, you can easily get an unexpected result if you access variables declared and intialized outside their intended scope. Apart from that, there is no notable difference between the control structures of both language. It must be mentioned that JS supports loop and block labeling for use of the continue and break statements. 

Functions are declared in a vastly different manner than their Java counterparts. We have already mentioned how the lack of access modifiers saddles the developer with managing the scope of their variables. However, this is true up to a point. There are several ways to declare a function in Javascript: First, you can declare a function in the global namespace. Function declared in a global scope must have a name . Functions may or may not include a list of expected arguments and may or may not return something. Functions are, by default, void. It is also possible to store functions in a variable, give this variable a name and execute the variable anywhere within its scope (example 10). 

Again, variables declared within the method are scoped within the method itself, rather than control flow structures, so any and all data that is created and used in the method is only accessible there. The argument list is an array-like object that can be referenced even when there are no expected arguments declared within the function. 

You can put arguments in a method that doesn’t specify them, reference the arguments object as if it was an array and use that data. The arguments object includes a .length property, however it doesn’t have .splice(), .join() or other Array Functions. There is a lot more that can be said about the arguments which we will talk about later. Suffice it to say, arguments in Javascript Functions work like an array (example 10). 

Numbers, booleans, and strings are passed by value, while Objects and all other data types are passed in arguments by reference. Functions themselves can pass as arguments of other functions, you can even declare, execute functions within functions, and even call them outside of the scope where they were initialized if the variable containing the function is declared outside of it (example 10). It's also possible to call a function and write an anonymous function as an argument, without the need of giving it a name or identifying it. The reason why is this possible is that functions themselves are first-class objects in the JS Programming Language. Again, everything is an object or based around objects. Because, functions themselves have methods of their own. These are .bind(), .apply(), and .call(), for now methods that escape the scope of this seminar.

The object is the backbone of Javascript, its alpha and omega, and the greatest departure from the Java programming language and what it grants it its almost chameleonic nature. As I mentioned earlier, there are no classes, interfaces, or abstracts in Javascript. This is the one of the most difficult concepts to understand as a developer who has worked in traditional object orientation, because it requires a different way of thinking. At first, you might find the way JS approaches objects to be counter-intuitive, but bear with me. Instead of the traditional class think about JS Objects in terms of associative hashes or dictionaries as implemented in Python. 

Objects are declared using the built-in constructor new Object, or with the Object Literal, which is two empty curly braces. Both of these methods create an empty Object. It's important to note that, unlike Java, declaring two variables with the object literal do not result in two variables pointing at the same object. All literals create objects independent objects from one another. An object holds reference names, which could correspond to functions, numbers, booleans, arrays, strings, or other objects. Like Java, they can be accesed and assigned using dot notation. You can also access fields using an array-esque notation, putting the name of the object, a pair of square brackets, and the name of the object field inside a string. The Engine will interpret this and return the field you are looking for. Furthermore, using the object literal you can intialize the object itself with all the necessary properties and methods the user decides, right from the get-go. Inside the object literal, variables are declared without the var keyword. Instead variables are initialized with a colon (:). Each variable is separated from each other with a comma, akin to initalizing a traditonal array(example 11). 

/*The JavaScript Object Notation is based on the simplicity of Javascript object literals. They are simple associative arrays, capable of contaning all data types, with the exception of functions. Declaring and initilaizing them is the same process as regular JS objects. However, once the data is ready to be transmitted, it's necessary to convert it to a string. The JSON global object contains a method called JSON.stringify() to do so. In order to parse a stringified JSON, recieved from another process or application, JSON.parse() is used. (example 11)*/

Objects are not tied down to static classes that determine what kind of data they can hold. All fields created within the local scope of the object are limited to that scope and others that may exist inside. However, what if I have two variables declared with the same name in two different scopes? What if the name of a variable conflicts directly with a global constant? How can we reconcile the lack of access modifiers with proper encapsulation? Eich responded to this conundrum with the "this" object. This serves as a way to distinguish between locally declared variables and fields belonging to a larger scope. When a function is executed, it gets the this property -- a variable with the value of the object that invokes the function where this is used. Because of this, the 'this' object contains the value of the object that invoked the function, a shortcut to the invoker of the function. 
As we go deeper in the scope chain, the value of 'this' becomes handy in accesing methods and variables that would normally be outside of scope. Observe example 12's execution. In global scope, "this" refers to the window object, the main container of all loaded scripts (example 12).

I have been mentioning something called a Global Object throught this session. We touched on it briefly, the object "this" refers when it is not encapsulated by any sort of function or object. The global object is a regular JavaScript object that serves a very important purpose: the properties of this object are the globally defined symbols that are available to a JavaScript program. When the JavaScript interpreter starts (or whenever a web browser loads a new page), it creates a new global object and gives it an initial set of properties that defines global properties, global functions, constructor functions like Date(), String(), Object(): and global objects like the JSON object we discussed a while ago. Javascript Engines encapsulate all variables, objects, and methods inside the global object. All the methods, variables, and objects from different script files go into the same global. When you declare variables without the var keyword and functions without a variable container, you initalize them into the global object. In browsers, the global object makes reference to an alternate name: window. This object has additional properties, such as location, outerWidth, sidebar, among others. However this is not always the case, as you may find javascript where there is no web browser window. However, all execution happens within the Global Object, where all the variables are widely accesible and modifiable by all possible scopes. This may seem like a good thing, but like public fields in Java objects, it's not a good idea to leave everything unencapsulated. Globally-declared varaibles have a problem when they are accidentally changed , creating errors that propagate in the execution. To remedy this, a good common practice is to namespace all objects within a custom object. By declaring everything within the object literal, or adding to it using dot notation, you ensure that everything in the context of execution will be limited to a scope of the developer's own choosing, rather than being vulnerable to the troubles of the global scope. To name this namespace, it's recommended to use a unique and consistent name in order to maintain code portability. If the namespaced code is spread out in multiple script files, it's important to always have a fallback should the namespacing object not exist. it's quite simple: 

/*var myNamespace = myNameSpace || {}.*/

By doing this, the developer secures the data and allows external libraries to play a role in one's own scripts. Namespace increases the portability of Javascript code considerably, making it cleaner and safer to execute (example 13).

For further information, do not hesitate to check Crockford on Javascript's seminar on the YUI Theater called The Javascript Programming Language.