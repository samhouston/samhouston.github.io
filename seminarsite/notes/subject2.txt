Executing code in Javascript is one of easiest things to accomplish. There are a plethora of ways to approach Javascript programming, but nothing beats its home turf: The Browser.

The fact that you are listening to this conference right now means that you are in the possession of a computer with a web browser, unless you are listening to this from a mobile device, in which case the following does not apply to you. 

Please Open a New Tab or Window of your web browser, right click anywhere on the screen. On the sub menu, please click Inspect Element. In a moment, either at the bottom or the right-hand side a window will open, containing the markup of your new tab page. You will see menus labeled Web Inspector, Elements, Network and others. Click on the Button that says "Console". This is the debug console to which the JS compiler prints. Click directly on the console's white space and type console.log("Hello World"): and click enter.

Congratulations, you have just executed a JavaScript script. Every Javascript Console can be used as an analog to Python's own Integrated Development Environment, running one line of code at a time. This is fine to experiment with a website that has already been loaded, modyfing the data or automating tedious tasks within the page. 

However, hacking the top layer of the frontend is just the beginning. To write your own javascript files and get the browser to execute them, you have to write an HTML file that references them. The scrip tag is the desginated markup for that effect. You can write the scripts directly into the markup, or you can reference an external file that contains the instructions in the src attribute, which is the best practice. Putting the tag at different places changes with what information the JS script executes. The best practice is to put the script tag on the bottom of the body tag in HTML. New non-standard attributes, like async and deferred, change the way scripts are loaded and will become standard in the future. (Refer to example, best practices to put script tags)

It's important to note that it is possible to concactenate multiple script files and have a file reference content that has already been declared and initialized in another script file. This is due to the fact that the in-browser engine loads scripts one after the other and pools all the data in a single Virtual Machine. This will make more sense as time goes and to some it may sound like a massive security oversight, but this particular feature enables an incredible amount of extensibility and modularity to large and complex applications. (refer to example 2)

If you feel that what you are doing in JS isn't large or important enough to warrant its own markup page or you are simply messing around with the language, as most people do, loading an html file with multiple scripts does feel like overkill. To this end, Google and Mozilla offer tools to write, save and execute code without the need to write HTML markup. JavaScript Editey for Google Chrome does just that: You write pure JS and let the browser execute it, with full access to console. Mozilla Aurora, the developer version of Firefox, offers such a feature out-of-the-box called Scratchpad.

To make things even simpler, there are multiple sites that allow users to write HTML, CSS, and Javascript inside their own mainframes, execute it and see the results live, without the need of downloading special browsers or even storing anything locally. JSFiddle.net is such a platform, and you also have the ability to save and share these code snippets with the world for free. Codepen.io offers the same service, however its designed differently with web design in mind. Runnable.com offers a similar service, allowing you to create your own file tree and even run PHP stacks, Python stacks, Node.js stacks and a plethora of other web technologies for free. It does not get easier than this and even more services are coming down the pipeline to make programming on the web even easier.

For people with a bit more experience who wish to have code autocompletion, linters, builders, and file management through services like Apache Ant, there are two alternatives: NetBeans WebStorm, a paid once of software that is by and far the best IDE for the web, and Sublime Text 3, which is my personal tool of choice. Sublime is an extensible, moddable, and flexible notepad program that stands out among text editors for its intuitive and clean design. Sublime Text 3 is technically shareware, but you can use the program for free almost indefinitely.

Apart from hardware costs, the setup costs to learn JS are zero. A plethora of tools, mods, tutorials, people, and community are available with a simple Google search and, like I mentioned before, if you have a web browser in a computer, you can execute Javascript.

This almost chamaleonic versatility is possible thanks to Javascript Engines, virtual machines that interpret and execute Javascript code. Brendan Eich built the first JS Engine, Spidermonkey, at the same time he was designing Javascript. Implemented in C++, at first the engine implemented Tracing Just-In-Time Compilation to optimize execution, recording control flow and data types, only to be replaced by a Whole-Method JIT Compiler. Today, SpiderMonkey powers Mozilla Firefox and Aurora. 

However, the fastest JS Engine in existence right now by far is Lars Bak's V8, today implemented in Google Chrome. It compiles JS code to native machine code before execution instead of interpreting it into bytecode, like the Java Compiler or the Spidermonkey engine. The code is optimize twice dynamically at runtime, making it the fastest on the world. Furthermore V8 was designed to break out of the browser space as a standalone, open-sourced engine that can be integrated into a multitude of projects, including a gem called Node.js that I will talk about later.

One Virtual Machine per Tab, per Window. The browser has come a long way and so has its programming language of choice.

Without further ado, let's dive into the syntax.